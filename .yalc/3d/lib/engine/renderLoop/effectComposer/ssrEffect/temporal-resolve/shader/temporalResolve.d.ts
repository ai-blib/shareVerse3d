declare const _default: "// a basic shader to implement temporal resolving\n\nuniform sampler2D inputTexture;\nuniform sampler2D accumulatedTexture;\nuniform sampler2D velocityTexture;\nuniform sampler2D lastVelocityTexture;\n\nuniform float blend;\nuniform float correction;\nuniform float exponent;\nuniform float samples;\nuniform vec2 invTexSize;\n\nuniform mat4 curInverseProjectionMatrix;\nuniform mat4 curCameraMatrixWorld;\nuniform mat4 prevInverseProjectionMatrix;\nuniform mat4 prevCameraMatrixWorld;\n\nvarying vec2 vUv;\n\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n#define FLOAT_EPSILON                 0.00001\n#define FLOAT_ONE_MINUS_EPSILON       0.99999\n\nvec3 transformexponent;\nvec3 undoColorTransformExponent;\n\n// idea from: https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\nvec3 transformColor(vec3 color) {\n    if (exponent == 1.0) return color;\n\n    return pow(abs(color), transformexponent);\n}\n\nvec3 undoColorTransform(vec3 color) {\n    if (exponent == 1.0) return color;\n\n    return max(pow(abs(color), undoColorTransformExponent), vec3(0.0));\n}\n\nvoid main() {\n    if (exponent != 1.0) {\n        transformexponent = vec3(1.0 / exponent);\n        undoColorTransformExponent = vec3(exponent);\n    }\n\n    vec4 inputTexel = textureLod(inputTexture, vUv, 0.0);\n    vec4 accumulatedTexel;\n\n    vec3 inputColor = transformColor(inputTexel.rgb);\n    vec3 accumulatedColor;\n\n    float alpha = inputTexel.a;\n\n    // REPROJECT_START\n\n    float velocityDisocclusion;\n    bool didReproject = false;\n\n#ifdef boxBlur\n    vec3 boxBlurredColor = inputTexel.rgb;\n#endif\n\n    vec4 velocity = textureLod(velocityTexture, vUv, 0.0);\n    bool isMoving = alpha < 1.0 || dot(velocity.xy, velocity.xy) > 0.0;\n\n    if (isMoving) {\n        vec3 minNeighborColor = inputColor;\n        vec3 maxNeighborColor = inputColor;\n\n        vec3 col;\n        vec2 neighborUv;\n\n        vec2 reprojectedUv = vUv - velocity.xy;\n        vec4 lastVelocity = textureLod(lastVelocityTexture, reprojectedUv, 0.0);\n\n        float depth = velocity.b;\n        float closestDepth = depth;\n        float lastClosestDepth = lastVelocity.b;\n        float neighborDepth;\n        float lastNeighborDepth;\n\n        for (int x = -correctionRadius; x <= correctionRadius; x++) {\n            for (int y = -correctionRadius; y <= correctionRadius; y++) {\n                if (x != 0 || y != 0) {\n                    neighborUv = vUv + vec2(x, y) * invTexSize;\n                    vec4 neigborVelocity = textureLod(velocityTexture, neighborUv, 0.0);\n                    neighborDepth = neigborVelocity.b;\n\n                    col = textureLod(inputTexture, neighborUv, 0.0).xyz;\n\n                    int absX = abs(x);\n                    int absY = abs(y);\n\n#ifdef dilation\n                    if (absX == 1 && absY == 1) {\n                        if (neighborDepth > closestDepth) {\n                            velocity = neigborVelocity;\n                            closestDepth = neighborDepth;\n                        }\n\n                        vec4 lastNeighborVelocity = textureLod(velocityTexture, vUv + vec2(x, y) * invTexSize, 0.0);\n                        lastNeighborDepth = lastNeighborVelocity.b;\n\n                        if (neighborDepth > closestDepth) {\n                            lastVelocity = lastNeighborVelocity;\n                            lastClosestDepth = lastNeighborDepth;\n                        }\n                    }\n#endif\n\n                    // the neighbor pixel is invalid if it's too far away from this pixel\n                    if (abs(depth - neighborDepth) < MAX_NEIGHBOR_DEPTH_DIFFERENCE) {\n#ifdef boxBlur\n                        if (absX <= 2 && absY <= 2) boxBlurredColor += col;\n#endif\n\n                        col = transformColor(col);\n\n                        minNeighborColor = min(col, minNeighborColor);\n                        maxNeighborColor = max(col, maxNeighborColor);\n                    }\n                }\n            }\n        }\n\n        // velocity\n        float velocityLength = length(lastVelocity.xy - velocity.xy);\n\n        // using the velocity to find disocclusions\n        velocityDisocclusion = (velocityLength - 0.000005) * 10.0;\n        velocityDisocclusion *= velocityDisocclusion;\n\n        reprojectedUv = vUv - velocity.xy;\n\n        // box blur\n\n#ifdef boxBlur\n        // box blur\n        float pxRadius = correctionRadius > 5 ? 121.0 : pow(float(correctionRadius * 2 + 1), 2.0);\n        boxBlurredColor /= pxRadius;\n        boxBlurredColor = transformColor(boxBlurredColor);\n#endif\n\n        // the reprojected UV coordinates are inside the view\n        if (reprojectedUv.x >= 0.0 && reprojectedUv.x <= 1.0 && reprojectedUv.y >= 0.0 && reprojectedUv.y <= 1.0) {\n            accumulatedTexel = textureLod(accumulatedTexture, reprojectedUv, 0.0);\n            accumulatedColor = transformColor(accumulatedTexel.rgb);\n\n            vec3 clampedColor = clamp(accumulatedColor, minNeighborColor, maxNeighborColor);\n\n            accumulatedColor = mix(accumulatedColor, clampedColor, correction);\n\n            didReproject = true;\n        } else {\n            // reprojected UV coordinates are outside of screen\n#ifdef boxBlur\n            accumulatedColor = boxBlurredColor;\n#else\n            accumulatedColor = inputColor;\n#endif\n        }\n\n        // this texel is marked as constantly moving (e.g. from a VideoTexture), so treat it accordingly\n        if (velocity.r > FLOAT_ONE_MINUS_EPSILON && velocity.g > FLOAT_ONE_MINUS_EPSILON) {\n            alpha = 0.0;\n            velocityDisocclusion = 1.0;\n        }\n    } else {\n        // there was no need to do neighborhood clamping, let's re-use the accumulated texel from the same UV coordinate\n        accumulatedColor = transformColor(textureLod(accumulatedTexture, vUv, 0.0).rgb);\n    }\n\n    // REPROJECT_END\n\n    vec3 outputColor = inputColor;\n\n    // the user's shader to compose a final outputColor from the inputTexel and accumulatedTexel\n#include <custom_compose_shader>\n\n    gl_FragColor = vec4(undoColorTransform(outputColor), alpha);\n}";
export default _default;
