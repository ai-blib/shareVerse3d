declare const _default: "// source: https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/SSAOShader.js\nvec3 getViewPosition(const float depth) {\n    float clipW = _projectionMatrix[2][3] * depth + _projectionMatrix[3][3];\n    vec4 clipPosition = vec4((vec3(vUv, depth) - 0.5) * 2.0, 1.0);\n    clipPosition *= clipW;\n    return (_inverseProjectionMatrix * clipPosition).xyz;\n}\n\n// source: https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/examples/js/shaders/SAOShader.js#L123\nfloat getViewZ(const in float depth) {\n#ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n#else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n#endif\n}\n\n// credits for transforming screen position to world position: https://discourse.threejs.org/t/reconstruct-world-position-in-screen-space-from-depth-buffer/5532/2\nvec3 screenSpaceToWorldSpace(const vec2 uv, const float depth) {\n    vec4 ndc = vec4(\n        (uv.x - 0.5) * 2.0,\n        (uv.y - 0.5) * 2.0,\n        (depth - 0.5) * 2.0,\n        1.0);\n\n    vec4 clip = _inverseProjectionMatrix * ndc;\n    vec4 view = cameraMatrixWorld * (clip / clip.w);\n\n    return view.xyz;\n}\n\n// vec2 worldSpaceToScreenSpace(vec3 worldPos){\n//     vec4 ssPos = _projectionMatrix * inverse(cameraMatrixWorld) * vec4(worldPos, 1.0);\n//     ssPos.xy /= ssPos.w;\n//     ssPos.xy = ssPos.xy * 0.5 + 0.5;\n\n//     return ssPos.xy;\n// }\n\n#define Scale (vec3(0.8, 0.8, 0.8))\n#define K     (19.19)\n\nvec3 hash(vec3 a) {\n    a = fract(a * Scale);\n    a += dot(a, a.yxz + K);\n    return fract((a.xxy + a.yxx) * a.zyx);\n}\n\n// source: https://github.com/blender/blender/blob/594f47ecd2d5367ca936cf6fc6ec8168c2b360d0/source/blender/gpu/shaders/material/gpu_shader_material_fresnel.glsl\nfloat fresnel_dielectric_cos(float cosi, float eta) {\n    /* compute fresnel reflectance without explicitly computing\n     * the refracted direction */\n    float c = abs(cosi);\n    float g = eta * eta - 1.0 + c * c;\n    float result;\n\n    if (g > 0.0) {\n        g = sqrt(g);\n        float A = (g - c) / (g + c);\n        float B = (c * (g + c) - 1.0) / (c * (g - c) + 1.0);\n        result = 0.5 * A * A * (1.0 + B * B);\n    } else {\n        result = 1.0; /* TIR (no refracted component) */\n    }\n\n    return result;\n}\n\n// source: https://github.com/blender/blender/blob/594f47ecd2d5367ca936cf6fc6ec8168c2b360d0/source/blender/gpu/shaders/material/gpu_shader_material_fresnel.glsl\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta) {\n    /* compute fresnel reflectance without explicitly computing\n     * the refracted direction */\n\n    float cosine = dot(Incoming, Normal);\n    return min(1.0, 5.0 * fresnel_dielectric_cos(cosine, eta));\n}";
export default _default;
